,
/*"windows": [
			{
				"fullscreen": false,
				"height": 600,
				"resizable": true,
				"title": "Project Securer",
				"width": 800
			}
		]*/
/**
    let application = tauri::Builder::default()
        .build(tauri::generate_context!())
        .expect("Error: Failed to run tauri application");

    let login_window = tauri::WindowBuilder::new(
        &application,
        "window_login",
        tauri::WindowUrl::App("index.html".into()),
    )
    //.icon(true)
    .hidden_title(true)
    .title("Login")
    .title_bar_style(tauri::TitleBarStyle::Visible)
    .build()
    .expect("Error: Failed to build window");

    application.run(());
    */
}

/*for index in 0..15 {
    let row: u8 = index / 4;
    let column: u8 = index % 4;

    let byte: u8 = state_matrix[row][column];

    let byte_binary: [bool; 8] = decimal_to_binary(byte);
    let row_index: u8 = binary_to_decimal(byte_binary[..4]);
    let column_index: u8 = binary_to_decimal(byte_binary[4..]);

    let s_box_byte: u8 = forward_s_box_matrix[row_index][column_index];

    new_state_matrix
}*/

/*let key_index: u8 = word_index / key_length_words;
            let key_word_index: u8 = word_index % key_length_words;

            if word_index < key_length_words {
                for byte in 0..3 {
                    final_key_matrix[key_index][byte][key_word_index] =
                        key_matrix[byte][key_word_index];
                }
            }*/

            for i in 0..15 {
                let row: u8 = i % 4;
                let column: u8 = i / 4;

                key_matrix[row][column] = key[i];
            }

            let last_column: [u8; 4] = [0; 4];

            for i in 0..3 {
                last_column[i] = key_matrix[i][3];
            }

            let rot_last_column: [u8; 4] = rot_word(last_column);
            let sub_last_column: [u8; 4] = sub_word(rot_last_column);
            let round_constant = get_round_constant(round);
            sub_last_column[0] += round_constant;
            let final_last_column = sub_last_column;

            let new_matrix: [[u8; 4]; 4] = [[0; 4]; 4];

            for column in 0..3 {
                if column == 0 {
                    for row in 0..3 {
                        new_matrix[row][column] = key_matrix[row][column] ^ final_last_column[row];
                    }
                } else {
                    for row in 0..3 {
                        new_matrix[row][column] = key_matrix[row][column] ^ new_matrix[row][column - 1];
                    }
                }
            }


             /*
    fn decimal_to_binary(integer: u8) -> [bool; 8] {
        let mut binary: [bool; 8] = [0; 8];
        let index: u8 = 0;

        while (integer > 0) {
            binary[index] = integer % 2;
            integer = integer / 2;
            index += 1;
        }

        return binary.reverse();
    }

    fn binary_to_decimal(binary: &[bool]) -> u8 {
        let decimal: u8 = 0;

        if binary.len() > 8 {
            return decimal;
        }

        for i in (binary.len() - 1)..0 {
            if binary[i] == 1 {
                decimal += 2.pow(i);
            }
        }

        return decimal;
    }
     */